# Summary

* [Introduction](README.md)
* [基础知识](基础知识.md)
   * [设计模式概述](设计模式概述.md)
       * [从招式与内功谈起——设计模式概述（一）](从招式与内功谈起——设计模式概述（一）.md)
       * [从招式与内功谈起——设计模式概述（二）](从招式与内功谈起——设计模式概述（二）.md)
       * [从招式与内功谈起——设计模式概述（三）](从招式与内功谈起——设计模式概述（三）.md)
   * [面向对象设计原则](面向对象设计原则.md)
       * [面向对象设计原则之单一职责原则](面向对象设计原则之单一职责原则.md)
       * [面向对象设计原则之开闭原则](面向对象设计原则之开闭原则.md)
       * [面向对象设计原则之里氏代换原则](面向对象设计原则之里氏代换原则.md)
       * [面向对象设计原则之依赖倒转原则](面向对象设计原则之依赖倒转原则.md)
       * [面向对象设计原则之接口隔离原则](面向对象设计原则之接口隔离原则.md)
       * [面向对象设计原则之合成复用原则](面向对象设计原则之合成复用原则.md)
       * [面向对象设计原则之迪米特法则](面向对象设计原则之迪米特法则.md)
* [六个创建型模式](六个创建型模式.md)
   * [简单工厂模式-Simple Factory Pattern](简单工厂模式-Simple Factory Pattern.md)
       * [工厂三兄弟之简单工厂模式（一）](工厂三兄弟之简单工厂模式（一）.md)
       * [工厂三兄弟之简单工厂模式（二）](工厂三兄弟之简单工厂模式（二）.md)
       * [工厂三兄弟之简单工厂模式（三）](工厂三兄弟之简单工厂模式（三）.md)
       * [工厂三兄弟之简单工厂模式（四）](工厂三兄弟之简单工厂模式（四）.md)
   * [工厂方法模式-Factory Method Pattern](工厂方法模式-Factory Method Pattern.md)
       * [工厂三兄弟之工厂方法模式（一）](工厂三兄弟之工厂方法模式（一）.md)
       * [工厂三兄弟之工厂方法模式（二）](工厂三兄弟之工厂方法模式（二）.md)
       * [工厂三兄弟之工厂方法模式（三）](工厂三兄弟之工厂方法模式（三）.md)
       * [工厂三兄弟之工厂方法模式（四）](工厂三兄弟之工厂方法模式（四）.md)
   * [抽象工厂模式-Abstract  Factory Pattern](抽象工厂模式-Abstract  Factory Pattern.md)
       * [工厂三兄弟之抽象工厂模式（一）](工厂三兄弟之抽象工厂模式（一）.md)
       * [工厂三兄弟之抽象工厂模式（二）](工厂三兄弟之抽象工厂模式（二）.md)
       * [工厂三兄弟之抽象工厂模式（三）](工厂三兄弟之抽象工厂模式（三）.md)
       * [工厂三兄弟之抽象工厂模式（四）](工厂三兄弟之抽象工厂模式（四）.md)
       * [工厂三兄弟之抽象工厂模式（五）](工厂三兄弟之抽象工厂模式（五）.md)
   * [单例模式-Singleton Pattern](单例模式-Singleton Pattern.md)
       * [确保对象的唯一性——单例模式 （一）](确保对象的唯一性——单例模式 （一）.md)
       * [确保对象的唯一性——单例模式 （二）](确保对象的唯一性——单例模式 （二）.md)
       * [确保对象的唯一性——单例模式 （三）](确保对象的唯一性——单例模式 （三）.md)
       * [确保对象的唯一性——单例模式 （四）](确保对象的唯一性——单例模式 （四）.md)
       * [确保对象的唯一性——单例模式 （五）](确保对象的唯一性——单例模式 （五）.md)
   * [原型模式-Prototype Pattern](原型模式-Prototype Pattern.md)
       * [对象的克隆——原型模式（一）](对象的克隆——原型模式（一）.md)
       * [对象的克隆——原型模式（二）](对象的克隆——原型模式（二）.md)
       * [对象的克隆——原型模式（三）](对象的克隆——原型模式（三）.md)
       * [对象的克隆——原型模式（四）](对象的克隆——原型模式（四）.md)
   * [建造者模式-Builder Pattern](建造者模式-Builder Pattern.md)
       * [复杂对象的组装与创建——建造者模式（一）](复杂对象的组装与创建——建造者模式（一）.md)
       * [复杂对象的组装与创建——建造者模式（二）](复杂对象的组装与创建——建造者模式（二）.md)
       * [复杂对象的组装与创建——建造者模式（三）](复杂对象的组装与创建——建造者模式（三）.md)
* [七个结构型模式](七个结构型模式.md)
   * [适配器模式-Adapter Pattern](适配器模式-Adapter Pattern.md)
       * [不兼容结构的协调——适配器模式（一）](不兼容结构的协调——适配器模式（一）.md)
       * [不兼容结构的协调——适配器模式（二）](不兼容结构的协调——适配器模式（二）.md)
       * [不兼容结构的协调——适配器模式（三）](不兼容结构的协调——适配器模式（三）.md)
       * [不兼容结构的协调——适配器模式（四）](不兼容结构的协调——适配器模式（四）.md)
   * [桥接模式-Bridge Pattern](桥接模式-Bridge Pattern.md)
       * [处理多维度变化——桥接模式（一）](处理多维度变化——桥接模式（一）.md)
       * [处理多维度变化——桥接模式（二）](处理多维度变化——桥接模式（二）.md)
       * [处理多维度变化——桥接模式（三）](处理多维度变化——桥接模式（三）.md)
       * [处理多维度变化——桥接模式（四）](处理多维度变化——桥接模式（四）.md)
   * [组合模式-Composite Pattern](组合模式-Composite Pattern.md)
       * [树形结构的处理——组合模式（一）](树形结构的处理——组合模式（一）.md)
       * [树形结构的处理——组合模式（二）](树形结构的处理——组合模式（二）.md)
       * [树形结构的处理——组合模式（三）](树形结构的处理——组合模式（三）.md)
       * [树形结构的处理——组合模式（四）](树形结构的处理——组合模式（四）.md)
       * [树形结构的处理——组合模式（五）](树形结构的处理——组合模式（五）.md)
   * [装饰模式-Decorator Pattern](装饰模式-Decorator Pattern.md)
       * [扩展系统功能——装饰模式（一）](扩展系统功能——装饰模式（一）.md)
       * [扩展系统功能——装饰模式（二）](扩展系统功能——装饰模式（二）.md)
       * [扩展系统功能——装饰模式（三）](扩展系统功能——装饰模式（三）.md)
       * [扩展系统功能——装饰模式（四）](扩展系统功能——装饰模式（四）.md)
   * [外观模式-Facade Pattern](外观模式-Facade Pattern.md)
       * [深入浅出外观模式（一）](深入浅出外观模式（一）.md)
       * [深入浅出外观模式（二）](深入浅出外观模式（二）.md)
       * [深入浅出外观模式（三）](深入浅出外观模式（三）.md)
   * [享元模式-Flyweight Pattern](享元模式-Flyweight Pattern.md)
       * [实现对象的复用——享元模式（一）](实现对象的复用——享元模式（一）.md)
       * [实现对象的复用——享元模式（二）](实现对象的复用——享元模式（二）.md)
       * [实现对象的复用——享元模式（三）](实现对象的复用——享元模式（三）.md)
       * [实现对象的复用——享元模式（四）](实现对象的复用——享元模式（四）.md)
       * [实现对象的复用——享元模式（五）](实现对象的复用——享元模式（五）.md)
   * [代理模式-Proxy Pattern](代理模式-Proxy Pattern.md)
       * [设计模式之代理模式（一）](设计模式之代理模式（一）.md)
       * [设计模式之代理模式（二）](设计模式之代理模式（二）.md)
       * [设计模式之代理模式（三）](设计模式之代理模式（三）.md)
       * [设计模式之代理模式（四）](设计模式之代理模式（四）.md)
* [十一个行为型模式](十一个行为型模式.md)
   * [职责链模式-Chain of Responsibility Pattern](职责链模式-Chain of Responsibility Pattern.md)
       * [请求的链式处理——职责链模式（一）](请求的链式处理——职责链模式（一）.md)
       * [请求的链式处理——职责链模式（二）](请求的链式处理——职责链模式（二）.md)
       * [请求的链式处理——职责链模式（三）](请求的链式处理——职责链模式（三）.md)
       * [请求的链式处理——职责链模式（四）](请求的链式处理——职责链模式（四）.md)
   * [命令模式-Command Pattern](命令模式-Command Pattern.md)
       * [请求发送者与接收者解耦——命令模式（一）](请求发送者与接收者解耦——命令模式（一）.md)
       * [请求发送者与接收者解耦——命令模式（二）](请求发送者与接收者解耦——命令模式（二）.md)
       * [请求发送者与接收者解耦——命令模式（三）](请求发送者与接收者解耦——命令模式（三）.md)
       * [请求发送者与接收者解耦——命令模式（四）](请求发送者与接收者解耦——命令模式（四）.md)
       * [请求发送者与接收者解耦——命令模式（五）](请求发送者与接收者解耦——命令模式（五）.md)
       * [请求发送者与接收者解耦——命令模式（六）](请求发送者与接收者解耦——命令模式（六）.md)
   * [解释器模式-Interpreter Pattern](解释器模式-Interpreter Pattern.md)
       * [自定义语言的实现——解释器模式（一）](自定义语言的实现——解释器模式（一）.md)
       * [自定义语言的实现——解释器模式（二）](自定义语言的实现——解释器模式（二）.md)
       * [自定义语言的实现——解释器模式（三）](自定义语言的实现——解释器模式（三）.md)
       * [自定义语言的实现——解释器模式（四）](自定义语言的实现——解释器模式（四）.md)
       * [自定义语言的实现——解释器模式（五）](自定义语言的实现——解释器模式（五）.md)
       * [自定义语言的实现——解释器模式（六）](自定义语言的实现——解释器模式（六）.md)
   * [迭代器模式-Iterator Pattern](迭代器模式-Iterator Pattern.md)
       * [遍历聚合对象中的元素——迭代器模式（一）](遍历聚合对象中的元素——迭代器模式（一）.md)
       * [遍历聚合对象中的元素——迭代器模式（二）](遍历聚合对象中的元素——迭代器模式（二）.md)
       * [遍历聚合对象中的元素——迭代器模式（三）](遍历聚合对象中的元素——迭代器模式（三）.md)
       * [遍历聚合对象中的元素——迭代器模式（四）](遍历聚合对象中的元素——迭代器模式（四）.md)
       * [遍历聚合对象中的元素——迭代器模式（五）](遍历聚合对象中的元素——迭代器模式（五）.md)
       * [遍历聚合对象中的元素——迭代器模式（六）](遍历聚合对象中的元素——迭代器模式（六）.md)
   * [中介者模式-Mediator Pattern](中介者模式-Mediator Pattern.md)
       * [协调多个对象之间的交互——中介者模式（一）](协调多个对象之间的交互——中介者模式（一）.md)
       * [协调多个对象之间的交互——中介者模式（二）](协调多个对象之间的交互——中介者模式（二）.md)
       * [协调多个对象之间的交互——中介者模式（三）](协调多个对象之间的交互——中介者模式（三）.md)
       * [协调多个对象之间的交互——中介者模式（四）](协调多个对象之间的交互——中介者模式（四）.md)
       * 20.4 中介者与同事类的扩展        Sunny软件公司CRM系统的客户对“客户信息管理窗口”提出了一个修改意见：要求在窗口的下端能够及时显示当前系统中客户信息的总数。修改之后的界面如图20-9所示：  图20-9 修改之后的“客户信息管理窗口”界面图        从图20-9中我们不难发现，可以通过增加一个文本标签(Label)来显示客户信息总数，而且当用户点击“增加”按钮或者“删除”按钮时，将改变文本标签的内容。       由于使用了中介者模式，在原有系统中增加新的组件（即新的同事类）将变得很容易，我们至少有如下两种解决方案：        【解决方案一】增加一个界面组件类Label，修改原有的具体中介者类ConcreteMediator，增加一个对Label对象的引用，然后修改componentChanged()方法中其他相关组件对象的业务处理代码，原有组件类无须任何修改，客户端代码也需针对新增组件Label进行适当修改。        【解决方案二】与方案一相同，首先增加一个Label类，但不修改原有具体中介者类ConcreteMediator的代码，而是增加一个ConcreteMediator的子类SubConcreteMediator来实现对Label对象的引用，然后在新增的中介者类SubConcreteMediator中通过覆盖componentChanged()方法来实现所有组件（包括新增Label组件）之间的交互，同样，原有组件类无须做任何修改，客户端代码需少许修改。       引入Label之后“客户信息管理窗口”类结构示意图如图20-10所示：  图20-10 增加Label组件类后的“客户信息管理窗口”结构示意图        由于【解决方案二】无须修改ConcreteMediator类，更符合“开闭原则”，因此我们选择该解决方案来对新增Label类进行处理，对应的完整类图如图20-11所示：  图20-11 修改之后的“客户信息管理窗口”结构图       在图20-11中，新增了具体同事类Label和具体中介者类SubConcreteMediator，代码如下所示： [java] view plain copy //文本标签类：具体同事类   class Label extends Component {       public void update() {           System.out.println("文本标签内容改变，客户信息总数加1。");       }   }      //新增具体中介者类   class SubConcreteMediator extends ConcreteMediator {       //增加对Label对象的引用       public Label label;              public void componentChanged(Component c) {           //单击按钮   if(c == addButton) {               System.out.println("--单击增加按钮--");               list.update();               cb.update();               userNameTextBox.update();               label.update(); //文本标签更新           }           //从列表框选择客户           else if(c == list) {               System.out.println("--从列表框选择客户--");               cb.select();               userNameTextBox.setText();           }           //从组合框选择客户           else if(c == cb) {               System.out.println("--从组合框选择客户--");               cb.select();               userNameTextBox.setText();           }       }   }          修改客户端测试代码： [java] view plain copy class Client {       public static void main(String args[]) {           //用新增具体中介者定义中介者对象           SubConcreteMediator mediator;           mediator = new SubConcreteMediator();                      Button addBT = new Button();           List list = new List();           ComboBox cb = new ComboBox();           TextBox userNameTB = new TextBox();           Label label = new Label();              addBT.setMediator(mediator);           list.setMediator(mediator);           cb.setMediator(mediator);           userNameTB.setMediator(mediator);           label.setMediator(mediator);                      mediator.addButton = addBT;           mediator.list = list;           mediator.cb = cb;           mediator.userNameTextBox = userNameTB;           mediator.label = label;                          addBT.changed();           System.out.println("-----------------------------");           list.changed();       }   }          编译并运行程序，输出结果如下： --单击增加按钮-- 列表框增加一项：张无忌。 组合框增加一项：张无忌。 客户信息增加成功后文本框清空。 文本标签内容改变，客户信息总数加1。 ----------------------------- --从列表框选择客户-- 组合框选中项：小龙女。 文本框显示：小龙女。        由于在本实例中不同的组件类（即不同的同事类）所拥有的方法并不完全相同，因此中介者类没有针对抽象同事类编程，导致在具体中介者类中需要维持对具体同事类的引用，客户端代码无法完全透明地对待所有同事类和中介者类。在某些情况下，如果设计得当，可以在客户端透明地对同事类和中介者类编程，这样系统将具有更好的灵活性和可扩展性。 疑问 思考 如果不使用中介者模式，按照图20-3所示设计方案，增加新组件时原有系统该如何修改？        在中介者模式的实际使用过程中，如果需要引入新的具体同事类，只需要继承抽象同事类并实现其中的方法即可，由于具体同事类之间并无直接的引用关系，因此原有所有同事类无须进行任何修改，它们与新增同事对象之间的交互可以通过修改或者增加具体中介者类来实现；如果需要在原有系统中增加新的具体中介者类，只需要继承抽象中介者类（或已有的具体中介者类）并覆盖其中定义的方法即可，在新的具体中介者中可以通过不同的方式来处理对象之间的交互，也可以增加对新增同事的引用和调用。在客户端中只需要修改少许代码（如果引入配置文件的话有时可以不修改任何代码）就可以实现中介者的更换。
       * 协调多个对象之间的交互——中介者模式（五）
   * [备忘录模式-Memento Pattern](备忘录模式-Memento Pattern.md)
   * [观察者模式-Observer Pattern](观察者模式-Observer Pattern.md)
   * [状态模式-State Pattern](状态模式-State Pattern.md)
   * [策略模式-Strategy Pattern](策略模式-Strategy Pattern.md)
   * [模板方法模式-Template Method Pattern](模板方法模式-Template Method Pattern.md)
   * [访问者模式-Visitor Pattern](访问者模式-Visitor Pattern.md)
* [设计模式综合应用实例](设计模式综合应用实例.md)
   * [多人联机射击游戏](多人联机射击游戏.md)
       * [多人联机射击游戏中的设计模式应用（一）](多人联机射击游戏中的设计模式应用（一）.md)
       * [多人联机射击游戏中的设计模式应用（二）](多人联机射击游戏中的设计模式应用（二）.md)
   * [数据库同步系统](数据库同步系统.md)
       * [设计模式综合实例分析之数据库同步系统（一）](设计模式综合实例分析之数据库同步系统（一）.md)
       * [设计模式综合实例分析之数据库同步系统（二）](设计模式综合实例分析之数据库同步系统（二）.md)
       * [设计模式综合实例分析之数据库同步系统（三）](设计模式综合实例分析之数据库同步系统（三）.md)

